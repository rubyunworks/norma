# XMLProof/Ruby - SQLCreator
#
#

require 'xmlproof/proofsheet'

module XMLProof

  # SQLCreator Class
	class SQLCreator
	
		attr_reader :sqls
	
		def initialize
			@sqls = nil
		end

    # Generates an array of SQL statements to create a database based on the given XMLProof proofsheet.
		def generate_sqls(xps)
			@xps_source = REXML::SourceFactory.create_from(xps)
			listener = SQLCreator_Listener.new
			REXML::Document.parse_stream(@xps_source, listener)
			@sqls = listener.build_sql
			return @sqls
		end
		
		
		private  # ------------------------------------------------
		
		# SQLCreator_Listener class is a REXML stream parser
		class SQLCreator_Listener
		
			attr_reader :sqls  # the array of sql statements generated by this listener
		
			#
			def initialize
				@root = nil                # stores the root tag whihc is rather useless to us
				@value = ''                # temp variable to hold field value
				@field = ''                # temp variable to hold field name
				@tag_stack = []            # this is a stack to track our current tag name (tags)
				@count = 0                 # a set cooresponds to a single sql statement which it numbers
				@table_count = 0           # total count of sets (i.e. sql statements)
				@table_count_stack = [ 0 ] # this is a stack to track our current set
				@table = []                # stores the table each set applies to (tagset_table)
				@table_columns = []        # stores xml attributes for each set, which are used in the where condition for update queries (tagset_conditions)
				@table_entry = {}          # stores [field, value] assoc. arrays to be used in sql statement
				@at_start = false          # have we just parsed a start tag?
				@at_end = false            # have we just parsed an end tag?
				@sqls = []                 # the array of sql statements generated by this listener
			end
			
			def method_missing(a, *b)
				raise "Method Missing: #{a}, #{b}"
			end
	
			def xmldecl(ver, enc, stand)
				# ignore xml declaration
			end
		
			def doctype(name, *contents)
				# ignore doctype
			end
			
			def instruction name, instruction
				# ignore any instructions (for now)
			end
			
			def comment comment
				# ignore comments
			end
				
			def tag_start name, attributes
				if not @root
					@root = name  # grab the root tag and get it out of the way, all subsequent parent tags must be table names
				else
					if @at_start
						@table_count_stack.push(@table_count)                # start the new table by pushing it onto the table stack
						@table[@table_count] = @tag_stack.last               # assign the table
						@table_columns[@table_count] = []                    # set up columns array for table
						@table_columns[@table_count] = @attributed_columns   # pickup held attributed columns if any
						@table_count += 1                                    # increment for next set
					end
					@tag_stack.push(name)                                  # push current tag name on to stack
					@attributed_columns = []                               # hold attributed columns if any
					attributes.each do |a|
						if a[0][0..2] != 'xp:'                                 # do not include control tags (those with xp: namespace)
							@attributed_columns << [ a[0], a[1] ]
						end
					end
					@at_start = true                                       # yes we just parsed a start tag
					@at_end = false                                        # and not an end tag
				end
			end
		
			def tag_end name
				if @at_end                                   # did we just parse an end tag and now we're doing another?
					@table_count_stack.pop                     # finish with this set by popping it off the stack
				else
					@table_columns[@count] << [@field, @value]   # assign the entry with the [field, value] assoc. array
				end
				@tag_stack.pop                               # finished with this tag, pop it off the stack
				@at_start = false                            # did not just parse a start tag
				@at_end = true                               # just parsed an end tag
			end
		
			def text value
					@value = value                             # hold the current contents of the current tag/column
					@field = @tag_stack.last                   # hold the current tag/column name
					@count = @table_count_stack.last           # hold the current table count
			end
		
			# build_sql method takes the listeners parse and creates the sql statements array
			def build_sql
				table_list = []                               # inititalize table list, holds the names of the tables done so far
				@table_count.times do |index|                 # loop though all the table entries gathered from the listener
					table = prefixless(@table[index])           # get table name, removing any namespace prefix
					if not table_list.include?(table)           # do not include tables already created with the same name, duplicate names are assumed to be the same table
						table_list << table                       # add table name to the list of created tables
						sql = "CREATE TABLE #{table} ("           # open sql create table query
						@table_columns[index].each do |col|       # loop through each column
							cn = prefixless(col[0])                 # get the column name, removing any namespace prefix
              col[1] =~ /.*::\s*(.+)/                 # want just the type and contraints
              sql = sql + "#{cn} #{$1},"              # add the column
						end
						sql = sql.chomp(',') + ');'               # close off the query
						@sqls << sql                              # add the query to the query array
					end
				end
				return @sqls                                  # return the array of create queries
			end  # def build_sql
			
      # Removes the namespace prefix from a tag name.
      def prefixless(tagname)
        if tagname =~ /[:]/
          return tagname.strip.split(':')[1]
        else
          return tagname.strip
        end
      end
      
		end # SQLCreator_Listener
		
	end # SQLCreator

end
